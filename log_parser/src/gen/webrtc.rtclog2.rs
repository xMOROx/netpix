// This file is @generated by prost-build.
/// At the top level, a WebRTC event log is just an EventStream object. Note that
/// concatenating multiple EventStreams in the same file is equivalent to a
/// single EventStream object containing the same events. Hence, it is not
/// necessary to wait for the entire log to be complete before beginning to
/// write it to a file.
/// Note: For all X_deltas fields, we rely on the default value being an
/// empty string.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventStream {
    /// Deprecated - Maintained for compatibility with the old event log.
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub stream: ::prost::alloc::vec::Vec<Event>,
    #[prost(message, repeated, tag = "2")]
    pub incoming_rtp_packets: ::prost::alloc::vec::Vec<IncomingRtpPackets>,
    #[prost(message, repeated, tag = "3")]
    pub outgoing_rtp_packets: ::prost::alloc::vec::Vec<OutgoingRtpPackets>,
    #[prost(message, repeated, tag = "4")]
    pub incoming_rtcp_packets: ::prost::alloc::vec::Vec<IncomingRtcpPackets>,
    #[prost(message, repeated, tag = "5")]
    pub outgoing_rtcp_packets: ::prost::alloc::vec::Vec<OutgoingRtcpPackets>,
    #[prost(message, repeated, tag = "6")]
    pub audio_playout_events: ::prost::alloc::vec::Vec<AudioPlayoutEvents>,
    #[prost(message, repeated, tag = "7")]
    pub frame_decoded_events: ::prost::alloc::vec::Vec<FrameDecodedEvents>,
    /// The field tags 8-15 are reserved for the most common events.
    #[prost(message, repeated, tag = "16")]
    pub begin_log_events: ::prost::alloc::vec::Vec<BeginLogEvent>,
    #[prost(message, repeated, tag = "17")]
    pub end_log_events: ::prost::alloc::vec::Vec<EndLogEvent>,
    #[prost(message, repeated, tag = "18")]
    pub loss_based_bwe_updates: ::prost::alloc::vec::Vec<LossBasedBweUpdates>,
    #[prost(message, repeated, tag = "19")]
    pub delay_based_bwe_updates: ::prost::alloc::vec::Vec<DelayBasedBweUpdates>,
    #[prost(message, repeated, tag = "20")]
    pub audio_network_adaptations: ::prost::alloc::vec::Vec<AudioNetworkAdaptations>,
    #[prost(message, repeated, tag = "21")]
    pub probe_clusters: ::prost::alloc::vec::Vec<BweProbeCluster>,
    #[prost(message, repeated, tag = "22")]
    pub probe_success: ::prost::alloc::vec::Vec<BweProbeResultSuccess>,
    #[prost(message, repeated, tag = "23")]
    pub probe_failure: ::prost::alloc::vec::Vec<BweProbeResultFailure>,
    #[prost(message, repeated, tag = "24")]
    pub alr_states: ::prost::alloc::vec::Vec<AlrState>,
    #[prost(message, repeated, tag = "25")]
    pub ice_candidate_configs: ::prost::alloc::vec::Vec<IceCandidatePairConfig>,
    #[prost(message, repeated, tag = "26")]
    pub ice_candidate_events: ::prost::alloc::vec::Vec<IceCandidatePairEvent>,
    #[prost(message, repeated, tag = "27")]
    pub dtls_transport_state_events: ::prost::alloc::vec::Vec<DtlsTransportStateEvent>,
    #[prost(message, repeated, tag = "28")]
    pub dtls_writable_states: ::prost::alloc::vec::Vec<DtlsWritableState>,
    #[prost(message, repeated, tag = "29")]
    pub generic_packets_sent: ::prost::alloc::vec::Vec<GenericPacketSent>,
    #[prost(message, repeated, tag = "30")]
    pub generic_packets_received: ::prost::alloc::vec::Vec<GenericPacketReceived>,
    #[prost(message, repeated, tag = "31")]
    pub generic_acks_received: ::prost::alloc::vec::Vec<GenericAckReceived>,
    #[prost(message, repeated, tag = "32")]
    pub route_changes: ::prost::alloc::vec::Vec<RouteChange>,
    #[prost(message, repeated, tag = "33")]
    pub remote_estimates: ::prost::alloc::vec::Vec<RemoteEstimates>,
    #[prost(message, repeated, tag = "34")]
    pub neteq_set_minimum_delay: ::prost::alloc::vec::Vec<NetEqSetMinimumDelay>,
    #[prost(message, repeated, tag = "101")]
    pub audio_recv_stream_configs: ::prost::alloc::vec::Vec<AudioRecvStreamConfig>,
    #[prost(message, repeated, tag = "102")]
    pub audio_send_stream_configs: ::prost::alloc::vec::Vec<AudioSendStreamConfig>,
    #[prost(message, repeated, tag = "103")]
    pub video_recv_stream_configs: ::prost::alloc::vec::Vec<VideoRecvStreamConfig>,
    #[prost(message, repeated, tag = "104")]
    pub video_send_stream_configs: ::prost::alloc::vec::Vec<VideoSendStreamConfig>,
}
/// DEPRECATED.
///
/// TODO(terelius): Do we want to preserve the old Event definition here?
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Event {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericPacketReceived {
    /// All fields are required.
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub packet_number: ::core::option::Option<i64>,
    /// Length of the packet in bytes.
    #[prost(int32, optional, tag = "3")]
    pub packet_length: ::core::option::Option<i32>,
    /// Provided if there are deltas in the batch.
    #[prost(uint32, optional, tag = "16")]
    pub number_of_deltas: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "17")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "18")]
    pub packet_number_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "19")]
    pub packet_length_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericPacketSent {
    /// All fields are required. All lengths in bytes.
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub packet_number: ::core::option::Option<i64>,
    /// overhead+payload+padding length = packet_length in bytes.
    #[prost(int32, optional, tag = "3")]
    pub overhead_length: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub payload_length: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub padding_length: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "16")]
    pub number_of_deltas: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "17")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "18")]
    pub packet_number_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "19")]
    pub overhead_length_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "20")]
    pub payload_length_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "21")]
    pub padding_length_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericAckReceived {
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// ID of the received packet.
    #[prost(int64, optional, tag = "2")]
    pub packet_number: ::core::option::Option<i64>,
    /// ID of the packet that was acked.
    #[prost(int64, optional, tag = "3")]
    pub acked_packet_number: ::core::option::Option<i64>,
    /// Timestamp in ms when the packet was received by the other side.
    #[prost(int64, optional, tag = "4")]
    pub receive_acked_packet_time_ms: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "16")]
    pub number_of_deltas: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "17")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "18")]
    pub packet_number_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "19")]
    pub acked_packet_number_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "20")]
    pub receive_acked_packet_time_ms_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyDescriptorsWireInfo {
    /// required
    /// Base and delta encoded B and E bits represented as two bit numbers.
    #[prost(uint32, optional, tag = "1")]
    pub start_end_bit: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub start_end_bit_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// required
    /// Base and delta encoded template IDs, represented as six bit numbers.
    #[prost(uint32, optional, tag = "3")]
    pub template_id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub template_id_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// required
    /// Base and delta compressed frame IDs.
    #[prost(uint32, optional, tag = "5")]
    pub frame_id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub frame_id_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// optional - set if any DD contains extended information.
    /// The extended info encoded as optional blobs.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub extended_infos: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncomingRtpPackets {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - RTP marker bit, used to label boundaries between video frames.
    #[prost(bool, optional, tag = "2")]
    pub marker: ::core::option::Option<bool>,
    /// required - RTP payload type.
    #[prost(uint32, optional, tag = "3")]
    pub payload_type: ::core::option::Option<u32>,
    /// required - RTP sequence number.
    #[prost(uint32, optional, tag = "4")]
    pub sequence_number: ::core::option::Option<u32>,
    /// required - RTP monotonic clock timestamp (not actual time).
    #[prost(fixed32, optional, tag = "5")]
    pub rtp_timestamp: ::core::option::Option<u32>,
    /// required - Synchronization source of this packet's RTP stream.
    #[prost(fixed32, optional, tag = "6")]
    pub ssrc: ::core::option::Option<u32>,
    /// required - The size (in bytes) of the media payload, not including
    /// RTP header or padding. The packet size is the sum of payload, header and
    /// padding.
    #[prost(uint32, optional, tag = "8")]
    pub payload_size: ::core::option::Option<u32>,
    /// required - The size (in bytes) of the RTP header.
    #[prost(uint32, optional, tag = "9")]
    pub header_size: ::core::option::Option<u32>,
    /// required - The size (in bytes) of the padding.
    #[prost(uint32, optional, tag = "10")]
    pub padding_size: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "11")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Optional header extensions.
    #[prost(uint32, optional, tag = "15")]
    pub transport_sequence_number: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "16")]
    pub transmission_time_offset: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "17")]
    pub absolute_send_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub video_rotation: ::core::option::Option<u32>,
    /// `audio_level` and `voice_activity` are always used in conjunction.
    #[prost(uint32, optional, tag = "19")]
    pub audio_level: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "20")]
    pub voice_activity: ::core::option::Option<bool>,
    /// Encodes all DD information in the batch, not just the base event.
    ///
    /// TODO(terelius): Add other header extensions like playout delay?
    #[prost(message, optional, tag = "21")]
    pub dependency_descriptor: ::core::option::Option<DependencyDescriptorsWireInfo>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub marker_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub payload_type_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "104")]
    pub sequence_number_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "105")]
    pub rtp_timestamp_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Field number 107 reserved for CSRC.
    #[prost(bytes = "vec", optional, tag = "106")]
    pub ssrc_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "108")]
    pub payload_size_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "109")]
    pub header_size_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "110")]
    pub padding_size_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Field number 111-114 reserved for future use.
    #[prost(bytes = "vec", optional, tag = "115")]
    pub transport_sequence_number_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", optional, tag = "116")]
    pub transmission_time_offset_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", optional, tag = "117")]
    pub absolute_send_time_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "118")]
    pub video_rotation_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// `audio_level` and `voice_activity` are always used in conjunction.
    #[prost(bytes = "vec", optional, tag = "119")]
    pub audio_level_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "120")]
    pub voice_activity_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutgoingRtpPackets {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - RTP marker bit, used to label boundaries between video frames.
    #[prost(bool, optional, tag = "2")]
    pub marker: ::core::option::Option<bool>,
    /// required - RTP payload type.
    #[prost(uint32, optional, tag = "3")]
    pub payload_type: ::core::option::Option<u32>,
    /// required - RTP sequence number.
    #[prost(uint32, optional, tag = "4")]
    pub sequence_number: ::core::option::Option<u32>,
    /// required - RTP monotonic clock timestamp (not actual time).
    #[prost(fixed32, optional, tag = "5")]
    pub rtp_timestamp: ::core::option::Option<u32>,
    /// required - Synchronization source of this packet's RTP stream.
    #[prost(fixed32, optional, tag = "6")]
    pub ssrc: ::core::option::Option<u32>,
    /// required - The size (in bytes) of the media payload, not including
    /// RTP header or padding. The packet size is the sum of payload, header and
    /// padding.
    #[prost(uint32, optional, tag = "8")]
    pub payload_size: ::core::option::Option<u32>,
    /// required - The size (in bytes) of the RTP header.
    #[prost(uint32, optional, tag = "9")]
    pub header_size: ::core::option::Option<u32>,
    /// required - The size (in bytes) of the padding.
    #[prost(uint32, optional, tag = "10")]
    pub padding_size: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "11")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Optional header extensions.
    #[prost(uint32, optional, tag = "15")]
    pub transport_sequence_number: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "16")]
    pub transmission_time_offset: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "17")]
    pub absolute_send_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub video_rotation: ::core::option::Option<u32>,
    /// `audio_level` and `voice_activity` are always used in conjunction.
    #[prost(uint32, optional, tag = "19")]
    pub audio_level: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "20")]
    pub voice_activity: ::core::option::Option<bool>,
    /// TODO(terelius): Add other header extensions like playout delay?
    /// Encodes all DD information in the batch, not just the base event.
    #[prost(message, optional, tag = "21")]
    pub dependency_descriptor: ::core::option::Option<DependencyDescriptorsWireInfo>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub marker_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub payload_type_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "104")]
    pub sequence_number_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "105")]
    pub rtp_timestamp_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "106")]
    pub ssrc_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Field number 107 reserved for CSRC.
    #[prost(bytes = "vec", optional, tag = "108")]
    pub payload_size_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "109")]
    pub header_size_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "110")]
    pub padding_size_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Field number 111-114 reserved for future use.
    #[prost(bytes = "vec", optional, tag = "115")]
    pub transport_sequence_number_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", optional, tag = "116")]
    pub transmission_time_offset_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", optional, tag = "117")]
    pub absolute_send_time_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "118")]
    pub video_rotation_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// `audio_level` and `voice_activity` are always used in conjunction.
    #[prost(bytes = "vec", optional, tag = "119")]
    pub audio_level_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "120")]
    pub voice_activity_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncomingRtcpPackets {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The whole packet including both payload and header.
    ///
    /// TODO(terelius): Feasible to log parsed RTCP instead?
    #[prost(bytes = "vec", optional, tag = "2")]
    pub raw_packet: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "3")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta/blob encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub raw_packet_blobs: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutgoingRtcpPackets {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The whole packet including both payload and header.
    ///
    /// TODO(terelius): Feasible to log parsed RTCP instead?
    #[prost(bytes = "vec", optional, tag = "2")]
    pub raw_packet: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "3")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta/blob encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub raw_packet_blobs: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioPlayoutEvents {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The SSRC of the audio stream associated with the playout event.
    #[prost(uint32, optional, tag = "2")]
    pub local_ssrc: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "3")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub local_ssrc_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetEqSetMinimumDelay {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The SSRC of the remote stream associated with the MinimumDelay
    /// event.
    #[prost(fixed32, optional, tag = "2")]
    pub remote_ssrc: ::core::option::Option<u32>,
    /// required - minimum delay passed to SetBaseMinimumDelay.
    #[prost(int32, optional, tag = "3")]
    pub minimum_delay_ms: ::core::option::Option<i32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "4")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub remote_ssrc_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub minimum_delay_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameDecodedEvents {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The SSRC of the video stream that the frame belongs to.
    #[prost(fixed32, optional, tag = "2")]
    pub ssrc: ::core::option::Option<u32>,
    /// required - The predicted render time of the frame.
    #[prost(int64, optional, tag = "3")]
    pub render_time_ms: ::core::option::Option<i64>,
    /// required - The width (in pixels) of the frame.
    #[prost(int32, optional, tag = "4")]
    pub width: ::core::option::Option<i32>,
    /// required - The height (in pixels) of the frame.
    #[prost(int32, optional, tag = "5")]
    pub height: ::core::option::Option<i32>,
    /// required - The codec type of the frame.
    #[prost(enumeration = "frame_decoded_events::Codec", optional, tag = "6")]
    pub codec: ::core::option::Option<i32>,
    /// required - The QP (quantization parameter) of the frame. Range \[0,255\].
    #[prost(uint32, optional, tag = "7")]
    pub qp: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "15")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub ssrc_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub render_time_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "104")]
    pub width_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "105")]
    pub height_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "106")]
    pub codec_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "107")]
    pub qp_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `FrameDecodedEvents`.
pub mod frame_decoded_events {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Codec {
        Unknown = 0,
        Generic = 1,
        Vp8 = 2,
        Vp9 = 3,
        Av1 = 4,
        H264 = 5,
        H265 = 6,
    }
    impl Codec {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "CODEC_UNKNOWN",
                Self::Generic => "CODEC_GENERIC",
                Self::Vp8 => "CODEC_VP8",
                Self::Vp9 => "CODEC_VP9",
                Self::Av1 => "CODEC_AV1",
                Self::H264 => "CODEC_H264",
                Self::H265 => "CODEC_H265",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CODEC_UNKNOWN" => Some(Self::Unknown),
                "CODEC_GENERIC" => Some(Self::Generic),
                "CODEC_VP8" => Some(Self::Vp8),
                "CODEC_VP9" => Some(Self::Vp9),
                "CODEC_AV1" => Some(Self::Av1),
                "CODEC_H264" => Some(Self::H264),
                "CODEC_H265" => Some(Self::H265),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BeginLogEvent {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required
    #[prost(uint32, optional, tag = "2")]
    pub version: ::core::option::Option<u32>,
    /// required
    #[prost(int64, optional, tag = "3")]
    pub utc_time_ms: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndLogEvent {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LossBasedBweUpdates {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// TODO(terelius): Update log interface to unsigned.
    /// required - Bandwidth estimate (in bps) after the update.
    #[prost(uint32, optional, tag = "2")]
    pub bitrate_bps: ::core::option::Option<u32>,
    /// required - Fraction of lost packets since last receiver report
    /// computed as floor( 256 * (#lost_packets / #total_packets) ).
    /// The possible values range from 0 to 255.
    #[prost(uint32, optional, tag = "3")]
    pub fraction_loss: ::core::option::Option<u32>,
    /// TODO(terelius): Is this really needed? Remove or make optional?
    /// TODO(terelius): Update log interface to unsigned.
    /// required - Total number of packets that the BWE update is based on.
    #[prost(uint32, optional, tag = "4")]
    pub total_packets: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "5")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub bitrate_bps_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub fraction_loss_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "104")]
    pub total_packets_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelayBasedBweUpdates {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - Bandwidth estimate (in bps) after the update.
    #[prost(uint32, optional, tag = "2")]
    pub bitrate_bps: ::core::option::Option<u32>,
    #[prost(enumeration = "delay_based_bwe_updates::DetectorState", optional, tag = "3")]
    pub detector_state: ::core::option::Option<i32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "4")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub bitrate_bps_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub detector_state_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `DelayBasedBweUpdates`.
pub mod delay_based_bwe_updates {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DetectorState {
        BweUnknownState = 0,
        BweNormal = 1,
        BweUnderusing = 2,
        BweOverusing = 3,
    }
    impl DetectorState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BweUnknownState => "BWE_UNKNOWN_STATE",
                Self::BweNormal => "BWE_NORMAL",
                Self::BweUnderusing => "BWE_UNDERUSING",
                Self::BweOverusing => "BWE_OVERUSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BWE_UNKNOWN_STATE" => Some(Self::BweUnknownState),
                "BWE_NORMAL" => Some(Self::BweNormal),
                "BWE_UNDERUSING" => Some(Self::BweUnderusing),
                "BWE_OVERUSING" => Some(Self::BweOverusing),
                _ => None,
            }
        }
    }
}
/// Maps RTP header extension names to numerical IDs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RtpHeaderExtensionConfig {
    /// Optional IDs for the header extensions. Each ID is a 4-bit number that is
    /// only set if that extension is configured.
    /// TODO: Can we skip audio level?
    #[prost(int32, optional, tag = "1")]
    pub transmission_time_offset_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub absolute_send_time_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub transport_sequence_number_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub video_rotation_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub audio_level_id: ::core::option::Option<i32>,
    /// TODO(terelius): Add other header extensions like playout delay?
    #[prost(int32, optional, tag = "6")]
    pub dependency_descriptor_id: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoRecvStreamConfig {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - Synchronization source (stream identifier) to be received.
    #[prost(uint32, optional, tag = "2")]
    pub remote_ssrc: ::core::option::Option<u32>,
    /// required - Sender SSRC used for sending RTCP (such as receiver reports).
    #[prost(uint32, optional, tag = "3")]
    pub local_ssrc: ::core::option::Option<u32>,
    /// optional - required if RTX is configured. SSRC for the RTX stream.
    #[prost(uint32, optional, tag = "4")]
    pub rtx_ssrc: ::core::option::Option<u32>,
    /// IDs for the header extension we care about. Only required if there are
    /// header extensions configured.
    #[prost(message, optional, tag = "5")]
    pub header_extensions: ::core::option::Option<RtpHeaderExtensionConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoSendStreamConfig {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - Synchronization source (stream identifier) for outgoing stream.
    /// When using simulcast, a separate config should be logged for each stream.
    #[prost(uint32, optional, tag = "2")]
    pub ssrc: ::core::option::Option<u32>,
    /// optional - required if RTX is configured. SSRC for the RTX stream.
    #[prost(uint32, optional, tag = "3")]
    pub rtx_ssrc: ::core::option::Option<u32>,
    /// IDs for the header extension we care about. Only required if there are
    /// header extensions configured.
    #[prost(message, optional, tag = "4")]
    pub header_extensions: ::core::option::Option<RtpHeaderExtensionConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioRecvStreamConfig {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - Synchronization source (stream identifier) to be received.
    #[prost(uint32, optional, tag = "2")]
    pub remote_ssrc: ::core::option::Option<u32>,
    /// required - Sender SSRC used for sending RTCP (such as receiver reports).
    #[prost(uint32, optional, tag = "3")]
    pub local_ssrc: ::core::option::Option<u32>,
    /// IDs for the header extension we care about. Only required if there are
    /// header extensions configured.
    #[prost(message, optional, tag = "5")]
    pub header_extensions: ::core::option::Option<RtpHeaderExtensionConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioSendStreamConfig {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - Synchronization source (stream identifier) for outgoing stream.
    #[prost(uint32, optional, tag = "2")]
    pub ssrc: ::core::option::Option<u32>,
    /// IDs for the header extension we care about. Only required if there are
    /// header extensions configured.
    #[prost(message, optional, tag = "4")]
    pub header_extensions: ::core::option::Option<RtpHeaderExtensionConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioNetworkAdaptations {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// Bit rate that the audio encoder is operating at.
    /// TODO(terelius): Signed vs unsigned?
    #[prost(int32, optional, tag = "2")]
    pub bitrate_bps: ::core::option::Option<i32>,
    /// Frame length that each encoded audio packet consists of.
    /// TODO(terelius): Signed vs unsigned?
    #[prost(int32, optional, tag = "3")]
    pub frame_length_ms: ::core::option::Option<i32>,
    /// Packet loss fraction that the encoder's forward error correction (FEC) is
    /// optimized for.
    /// Instead of encoding a float, we encode a value between 0 and 16383, which
    /// if divided by 16383, will give a value close to the original float.
    /// The value 16383 (2^14 - 1) was chosen so that it would give good precision
    /// on the one hand, and would be encodable with two bytes in varint form
    /// on the other hand.
    #[prost(uint32, optional, tag = "4")]
    pub uplink_packet_loss_fraction: ::core::option::Option<u32>,
    /// Whether forward error correction (FEC) is turned on or off.
    #[prost(bool, optional, tag = "5")]
    pub enable_fec: ::core::option::Option<bool>,
    /// Whether discontinuous transmission (DTX) is turned on or off.
    #[prost(bool, optional, tag = "6")]
    pub enable_dtx: ::core::option::Option<bool>,
    /// Number of audio channels that each encoded packet consists of.
    #[prost(uint32, optional, tag = "7")]
    pub num_channels: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "8")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub bitrate_bps_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub frame_length_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "104")]
    pub uplink_packet_loss_fraction_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", optional, tag = "105")]
    pub enable_fec_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "106")]
    pub enable_dtx_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "107")]
    pub num_channels_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BweProbeCluster {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The id of this probe cluster.
    #[prost(uint32, optional, tag = "2")]
    pub id: ::core::option::Option<u32>,
    /// required - The bitrate in bps that this probe cluster is meant to probe.
    #[prost(uint32, optional, tag = "3")]
    pub bitrate_bps: ::core::option::Option<u32>,
    /// required - The minimum number of packets used to probe the given bitrate.
    #[prost(uint32, optional, tag = "4")]
    pub min_packets: ::core::option::Option<u32>,
    /// required - The minimum number of bytes used to probe the given bitrate.
    #[prost(uint32, optional, tag = "5")]
    pub min_bytes: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BweProbeResultSuccess {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The id of this probe cluster.
    #[prost(uint32, optional, tag = "2")]
    pub id: ::core::option::Option<u32>,
    /// required - The resulting bitrate in bps.
    #[prost(uint32, optional, tag = "3")]
    pub bitrate_bps: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BweProbeResultFailure {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - The id of this probe cluster.
    #[prost(uint32, optional, tag = "2")]
    pub id: ::core::option::Option<u32>,
    /// required
    #[prost(
        enumeration = "bwe_probe_result_failure::FailureReason",
        optional,
        tag = "3"
    )]
    pub failure: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BweProbeResultFailure`.
pub mod bwe_probe_result_failure {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureReason {
        Unknown = 0,
        InvalidSendReceiveInterval = 1,
        InvalidSendReceiveRatio = 2,
        Timeout = 3,
    }
    impl FailureReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::InvalidSendReceiveInterval => "INVALID_SEND_RECEIVE_INTERVAL",
                Self::InvalidSendReceiveRatio => "INVALID_SEND_RECEIVE_RATIO",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_SEND_RECEIVE_INTERVAL" => Some(Self::InvalidSendReceiveInterval),
                "INVALID_SEND_RECEIVE_RATIO" => Some(Self::InvalidSendReceiveRatio),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlrState {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - True if the send rate is application limited.
    #[prost(bool, optional, tag = "2")]
    pub in_alr: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IceCandidatePairConfig {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required
    #[prost(
        enumeration = "ice_candidate_pair_config::IceCandidatePairConfigType",
        optional,
        tag = "2"
    )]
    pub config_type: ::core::option::Option<i32>,
    /// required
    #[prost(uint32, optional, tag = "3")]
    pub candidate_pair_id: ::core::option::Option<u32>,
    /// required
    #[prost(
        enumeration = "ice_candidate_pair_config::IceCandidateType",
        optional,
        tag = "4"
    )]
    pub local_candidate_type: ::core::option::Option<i32>,
    /// required
    #[prost(enumeration = "ice_candidate_pair_config::Protocol", optional, tag = "5")]
    pub local_relay_protocol: ::core::option::Option<i32>,
    /// required
    #[prost(enumeration = "ice_candidate_pair_config::NetworkType", optional, tag = "6")]
    pub local_network_type: ::core::option::Option<i32>,
    /// required
    #[prost(
        enumeration = "ice_candidate_pair_config::AddressFamily",
        optional,
        tag = "7"
    )]
    pub local_address_family: ::core::option::Option<i32>,
    /// required
    #[prost(
        enumeration = "ice_candidate_pair_config::IceCandidateType",
        optional,
        tag = "8"
    )]
    pub remote_candidate_type: ::core::option::Option<i32>,
    /// required
    #[prost(
        enumeration = "ice_candidate_pair_config::AddressFamily",
        optional,
        tag = "9"
    )]
    pub remote_address_family: ::core::option::Option<i32>,
    /// required
    #[prost(enumeration = "ice_candidate_pair_config::Protocol", optional, tag = "10")]
    pub candidate_pair_protocol: ::core::option::Option<i32>,
}
/// Nested message and enum types in `IceCandidatePairConfig`.
pub mod ice_candidate_pair_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IceCandidatePairConfigType {
        UnknownConfigType = 0,
        Added = 1,
        Updated = 2,
        Destroyed = 3,
        Selected = 4,
    }
    impl IceCandidatePairConfigType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownConfigType => "UNKNOWN_CONFIG_TYPE",
                Self::Added => "ADDED",
                Self::Updated => "UPDATED",
                Self::Destroyed => "DESTROYED",
                Self::Selected => "SELECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CONFIG_TYPE" => Some(Self::UnknownConfigType),
                "ADDED" => Some(Self::Added),
                "UPDATED" => Some(Self::Updated),
                "DESTROYED" => Some(Self::Destroyed),
                "SELECTED" => Some(Self::Selected),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IceCandidateType {
        UnknownCandidateType = 0,
        Local = 1,
        Stun = 2,
        Prflx = 3,
        Relay = 4,
    }
    impl IceCandidateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownCandidateType => "UNKNOWN_CANDIDATE_TYPE",
                Self::Local => "LOCAL",
                Self::Stun => "STUN",
                Self::Prflx => "PRFLX",
                Self::Relay => "RELAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CANDIDATE_TYPE" => Some(Self::UnknownCandidateType),
                "LOCAL" => Some(Self::Local),
                "STUN" => Some(Self::Stun),
                "PRFLX" => Some(Self::Prflx),
                "RELAY" => Some(Self::Relay),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        UnknownProtocol = 0,
        Udp = 1,
        Tcp = 2,
        Ssltcp = 3,
        Tls = 4,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownProtocol => "UNKNOWN_PROTOCOL",
                Self::Udp => "UDP",
                Self::Tcp => "TCP",
                Self::Ssltcp => "SSLTCP",
                Self::Tls => "TLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_PROTOCOL" => Some(Self::UnknownProtocol),
                "UDP" => Some(Self::Udp),
                "TCP" => Some(Self::Tcp),
                "SSLTCP" => Some(Self::Ssltcp),
                "TLS" => Some(Self::Tls),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AddressFamily {
        UnknownAddressFamily = 0,
        Ipv4 = 1,
        Ipv6 = 2,
    }
    impl AddressFamily {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownAddressFamily => "UNKNOWN_ADDRESS_FAMILY",
                Self::Ipv4 => "IPV4",
                Self::Ipv6 => "IPV6",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_ADDRESS_FAMILY" => Some(Self::UnknownAddressFamily),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkType {
        UnknownNetworkType = 0,
        Ethernet = 1,
        Wifi = 2,
        Cellular = 3,
        Vpn = 4,
        Loopback = 5,
    }
    impl NetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownNetworkType => "UNKNOWN_NETWORK_TYPE",
                Self::Ethernet => "ETHERNET",
                Self::Wifi => "WIFI",
                Self::Cellular => "CELLULAR",
                Self::Vpn => "VPN",
                Self::Loopback => "LOOPBACK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_NETWORK_TYPE" => Some(Self::UnknownNetworkType),
                "ETHERNET" => Some(Self::Ethernet),
                "WIFI" => Some(Self::Wifi),
                "CELLULAR" => Some(Self::Cellular),
                "VPN" => Some(Self::Vpn),
                "LOOPBACK" => Some(Self::Loopback),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IceCandidatePairEvent {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required
    #[prost(
        enumeration = "ice_candidate_pair_event::IceCandidatePairEventType",
        optional,
        tag = "2"
    )]
    pub event_type: ::core::option::Option<i32>,
    /// required
    #[prost(uint32, optional, tag = "3")]
    pub candidate_pair_id: ::core::option::Option<u32>,
    /// required
    #[prost(uint32, optional, tag = "4")]
    pub transaction_id: ::core::option::Option<u32>,
}
/// Nested message and enum types in `IceCandidatePairEvent`.
pub mod ice_candidate_pair_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IceCandidatePairEventType {
        UnknownCheckType = 0,
        CheckSent = 1,
        CheckReceived = 2,
        CheckResponseSent = 3,
        CheckResponseReceived = 4,
    }
    impl IceCandidatePairEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownCheckType => "UNKNOWN_CHECK_TYPE",
                Self::CheckSent => "CHECK_SENT",
                Self::CheckReceived => "CHECK_RECEIVED",
                Self::CheckResponseSent => "CHECK_RESPONSE_SENT",
                Self::CheckResponseReceived => "CHECK_RESPONSE_RECEIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CHECK_TYPE" => Some(Self::UnknownCheckType),
                "CHECK_SENT" => Some(Self::CheckSent),
                "CHECK_RECEIVED" => Some(Self::CheckReceived),
                "CHECK_RESPONSE_SENT" => Some(Self::CheckResponseSent),
                "CHECK_RESPONSE_RECEIVED" => Some(Self::CheckResponseReceived),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DtlsTransportStateEvent {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required
    #[prost(
        enumeration = "dtls_transport_state_event::DtlsTransportState",
        optional,
        tag = "2"
    )]
    pub dtls_transport_state: ::core::option::Option<i32>,
}
/// Nested message and enum types in `DtlsTransportStateEvent`.
pub mod dtls_transport_state_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DtlsTransportState {
        UnknownDtlsTransportState = 0,
        DtlsTransportNew = 1,
        DtlsTransportConnecting = 2,
        DtlsTransportConnected = 3,
        DtlsTransportClosed = 4,
        DtlsTransportFailed = 5,
    }
    impl DtlsTransportState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownDtlsTransportState => "UNKNOWN_DTLS_TRANSPORT_STATE",
                Self::DtlsTransportNew => "DTLS_TRANSPORT_NEW",
                Self::DtlsTransportConnecting => "DTLS_TRANSPORT_CONNECTING",
                Self::DtlsTransportConnected => "DTLS_TRANSPORT_CONNECTED",
                Self::DtlsTransportClosed => "DTLS_TRANSPORT_CLOSED",
                Self::DtlsTransportFailed => "DTLS_TRANSPORT_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_DTLS_TRANSPORT_STATE" => Some(Self::UnknownDtlsTransportState),
                "DTLS_TRANSPORT_NEW" => Some(Self::DtlsTransportNew),
                "DTLS_TRANSPORT_CONNECTING" => Some(Self::DtlsTransportConnecting),
                "DTLS_TRANSPORT_CONNECTED" => Some(Self::DtlsTransportConnected),
                "DTLS_TRANSPORT_CLOSED" => Some(Self::DtlsTransportClosed),
                "DTLS_TRANSPORT_FAILED" => Some(Self::DtlsTransportFailed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DtlsWritableState {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required
    #[prost(bool, optional, tag = "2")]
    pub writable: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RouteChange {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// required - True if the route is ready for sending packets.
    #[prost(bool, optional, tag = "2")]
    pub connected: ::core::option::Option<bool>,
    /// required - The per packet data overhead for this route.
    #[prost(uint32, optional, tag = "3")]
    pub overhead: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteEstimates {
    /// required
    #[prost(int64, optional, tag = "1")]
    pub timestamp_ms: ::core::option::Option<i64>,
    /// optional - value used as a safe measure of available capacity.
    #[prost(uint32, optional, tag = "2")]
    pub link_capacity_lower_kbps: ::core::option::Option<u32>,
    /// optional - value used as limit for increasing bitrate.
    #[prost(uint32, optional, tag = "3")]
    pub link_capacity_upper_kbps: ::core::option::Option<u32>,
    /// optional - required if the batch contains delta encoded events.
    #[prost(uint32, optional, tag = "4")]
    pub number_of_deltas: ::core::option::Option<u32>,
    /// Delta encodings.
    #[prost(bytes = "vec", optional, tag = "101")]
    pub timestamp_ms_deltas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "102")]
    pub link_capacity_lower_kbps_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", optional, tag = "103")]
    pub link_capacity_upper_kbps_deltas: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
}
